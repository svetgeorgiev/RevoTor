#include "Battery_Shield.h"																								//
																														//
//		Инициализация battery shield.																					//	Возвращаемое значение: флаг результата инициализации true/false.
bool	Battery_Shield::begin(float res, float cua){																	//	Параметр: значение сопротивления в Ом, [значение КПД в %].
//			Сохраняем принятые значения:																				//
			valResistor = res;																							//	Сохраняем сопротивление в цепи аккумуляторной батареи.
			if(cua!=IP5108_EFFICIENCY){ valEfficiency = cua/100.0; }													//	Сохраняем КПД повышающего DC-DC преобразователя (пререведя % в абсолютные значения от 0 до 1)
//			Инициируем работу с шиной I2C:																				//
			objI2C->begin(100);																							//	Инициируем передачу данных по шине I2C на скорости 100 кГц.
//			Запрещаем модулю отключаться при отсутствии нагрузки:														//	
			uint8_t i=0; while(!_noSleep() && i<10){i++; delay(10);}													//	Выполняем отправку запрета в цикле while(), пока модуль не примет запрет, или пока значение i не достигнет 10.
//			Возвращаем результат инициализации:																			//
			return i<10?true:false;																						//	Если значение i не достигло 10, значит модуль ответил, приняв запрет на выключение, тогда возвращаем true.
}																														//
																														//
//		Выключение battery shield:																						//	Возвращаемое значение: флаг результата выключения true/false.
bool	Battery_Shield::off(void){																						//	Параметр: отсутствует.
			if(			objI2C->readBytes(IP5108_ADDRESS, IP5108_SYS_CTL4,  valRegistor, 1) ){							//	Если удалось прочитать значение регистра IP5108_SYS_CTL4 в элемент массива valRegistor[0], то ...
				return	objI2C->writeByte(IP5108_ADDRESS, IP5108_SYS_CTL4, (valRegistor[0]|bit(7)) );					//	Сохраняем значение в регистр IP5108_SYS_CTL4 из элемента массива valRegistor[0], предварительно установив 7 бит.
			}else{		return false;}																					//	Иначе, если не удалось прочитать значение регистра IP5108_SYS_CTL4, то запрещаем модулю отключаться при отсутствии нагрузки и возвращаем false.
}																														//
																														//
//		Управление зарядным устройством:																				//	Возвращаемое значение: отсутствует.
void	Battery_Shield::charging(bool flgEnCharging){																	//	Параметр: флаг разрешения работы зарядного устройства - да/нет.
			_noSleep();																									//	Запрещаем модулю отключаться при отсутствии нагрузки.
			if(	objI2C->readBytes(IP5108_ADDRESS, IP5108_SYS_CTL0, valRegistor, 1) ){									//	Если удалось прочитать значение регистра IP5108_SYS_CTL0 в элемент массива valRegistor[0], то ...
				if(flgEnCharging)	{objI2C->writeByte(IP5108_ADDRESS, IP5108_SYS_CTL0, (valRegistor[0]|  bit(1) ) );}	//	Сохраняем значение в регистр IP5108_SYS_CTL0 из элемента массива valRegistor[0], предварительно установив 1 бит.
				else				{objI2C->writeByte(IP5108_ADDRESS, IP5108_SYS_CTL0, (valRegistor[0]&(~bit(1))) );}	//	Сохраняем значение в регистр IP5108_SYS_CTL0 из элемента массива valRegistor[0], предварительно сбросив   1 бит.
			}																											//
}																														//
																														//
//		Получение текущего уровня заряда батареи:																		//	Возвращаемое значение: процент заряда от 0 до 100.
uint8_t	Battery_Shield::getLevel(void){																					//	Параметр: отсутствует.
			float i = voltmeter(BATTERY_IDLE);																			//	Определяем временную переменную со значением Vbat без нагрузки.
			if(i>4.15f){return 100;}																					//	96-100%
			if(i>4.11f){return 95;}																						//	91-95%
			if(i>4.08f){return 90;}																						//	86-90%
			if(i>4.02f){return 85;}																						//	81-85%
			if(i>3.98f){return 80;}																						//	76-80%
			if(i>3.95f){return 75;}																						//	71-75%
			if(i>3.91f){return 70;}																						//	66-70%
			if(i>3.87f){return 65;}																						//	61-65%
			if(i>3.85f){return 60;}																						//	56-60%
			if(i>3.84f){return 55;}																						//	51-55%
			if(i>3.82f){return 50;}																						//	46-50%
			if(i>3.80f){return 45;}																						//	41-45%
			if(i>3.79f){return 40;}																						//	36-40%
			if(i>3.77f){return 35;}																						//	31-35%
			if(i>3.75f){return 30;}																						//	26-30%
			if(i>3.73f){return 25;}																						//	21-25%
			if(i>3.71f){return 20;}																						//	16-20%
			if(i>3.69f){return 15;}																						//	11-15%
			if(i>3.61f){return 10;}																						//	06-10%
			if(i>3.27f){return 5; }																						//	01-05%
						return 0;																						//	   00%
}																														//
																														//
//		Получение текущего режима заряда батареи:																		//	Возвращаемое значение: константа CHARGING_IDLE, или CHARGING_TK, или CHARGING_CC, или CHARGING_CV, или CHARGING_TO.
uint8_t	Battery_Shield::getState(void){																					//	Параметр: отсутствует.
			_noSleep();																									//	Запрещаем модулю отключаться при отсутствии нагрузки.
			if(	objI2C->readBytes(IP5108_ADDRESS, IP5108_REG_READ1, valRegistor, 1) ){									//	Если удалось прочитать значение регистра IP5108_REG_READ1 в элемент массива valRegistor[0], то ...
				valRegistor[0]>>=5;																						//	Сдвигаем полученные данные на 5 битов, так что бы биты 7-5 стали битами 2-0.
				switch(valRegistor[0]){																					//	Возвращаемый результат зависит от прочитанного значения...
					case 0b000:	return CHARGING_IDLE;	break;															//	Заряд аккумулятора не выполняется.
					case 0b001:	return CHARGING_TK;		break;															//	Заряд аккумулятора выполняется в режиме TK - малым током            (значит аккумулятор сейчас сильно разряжен).
					case 0b010:	return CHARGING_CC;		break;															//	Заряд аккумулятора выполняется в режиме CC - постоянным током       (основной режим заряда аккумулятора).
					case 0b100:	return CHARGING_CV;		break;															//	Заряд аккумулятора выполняется в режиме CV - постоянным напряжением (заключительный режим заряда аккумулятора).
					case 0b101:	return CHARGING_TO;		break;															//	Время заряда вышло.
					case 0b110:	return CHARGING_TO;		break;															//	Время заряда вышло.
					default:	return CHARGING_IDLE;	break;															//	Заряд аккумулятора не выполняется.
				}																										//
			}else{				return CHARGING_IDLE;}																	//	Иначе, если не удалось прочитать значение регистра IP5108_REG_READ1, то возвращаем CHARGING_IDLE.
}																														//
																														//
//		Получение силы тока:																							//	Возвращаемое значение: сила тока в А.
float	Battery_Shield::amperemeter(uint8_t i){																			//	Параметр: цепь, ток которой требуется получить: INPUT = BATTERY, OUTPUT.
			float Vout;																									//	Объявляем временную переменную для хранения напряжения на выходе.
            switch(i){																									//	Возвращаемый результат зависит от параметра i
				case BATTERY:	return voltmeter(RESISTOR)/valResistor;	break;											//	Ibat = Vbat / R.
				case OUTPUT:	Vout = voltmeter(OUTPUT); if(Vout==0){return 0;}										//	Если Vout равно 0, то возвращаем 0 и выходим из функции, так как в следующей строке Vout является делителем.
								return voltmeter(BATTERY)*amperemeter(BATTERY)*valEfficiency/Vout; break;				//	Iout = Pout/Vout = Pbat*КПД/Vout = Vbat*Ibat*КПД/Vout.   ( т.к:   Pout = Pin*КПД,   Pin = Pbat = Vbat*Ibat ).
				default:		return 0;								break;											//	Неизвестный параметр получит 0В.
			}																											//
}																														//
																														//
//		Получение напряжения:																							//	Возвращаемое значение: Напряжение в В.
float	Battery_Shield::voltmeter(uint8_t i){																			//	Параметр: блок на котором требуется измерить напряжение: INPUT = BATTERY, OUTPUT, BATTERY_IDLE, RESISTOR.
			float j=0;																									//	Определяем временную переменную для вывода результата.
            switch(i){																									//	Возвращаемый результат зависит от параметра i
				case OUTPUT:		j = _ADC(IP5108_OUT_V_ADC_DAT0) * (2.2f/8192.0f);	if(j){j+=3.2f;}	break;			//	Vout = АЦП * (2,2В/2^13) + 3,2В.
				case BATTERY:		j = _ADC(IP5108_BAT_V_ADC_DAT0) * (2.2f/8192.0f);	if(j){j+=2.6f;}	break;			//	Vbat = АЦП * (2,2В/2^13) + 2,6В.
				case BATTERY_IDLE:	j = _ADC(IP5108_BAT_OCV_DAT0  ) * (2.2f/8192.0f);	if(j){j+=2.6f;}	break;			//	Vbat = АЦП * (2,2В/2^13) + 2,6В. Без нагрузки
				case RESISTOR:		j = _ADC(IP5108_BAT_I_ADC_DAT0) * (2.2f/294912.0f);	      j*=-1.0f;	break;			//	Vres = АЦП * 2,2В/(2^13 * 36).
			}																											//
			return j;																									//	Возвращаем результат.
}																														//
																														//
//		Получение сопротивления:																						//	Возвращаемое значение: Сопротивление в Ом. (данное значение можно использовать при вызове функции begin)
float	Battery_Shield::ohmmeter(float I_BAT_USER){																		//	Параметр: сила тока в цепи аккумулятора, измеряется пользователем.
			if(I_BAT_USER != 0)	{return voltmeter(RESISTOR)/I_BAT_USER;}												//	R=U/I.
			else				{return 1.0f;}																			//	Если юзер ввёл ток равный 0 А, то возвращаем ему 1 Ом. Юзер не знает, что мы собираемся делить на его 0.
}																														//
																														//
//		Получение КПД в %:																								//	Возвращаемое значение: КПД повышающего DC-DC преобразователя в %. (данное значение можно использовать при вызове функции begin)
float	Battery_Shield::efficiency(float I_OUT_USER){																	//	Параметр: сила тока в цепи нагрузки (выхода), измеряется пользователем.
			float Pin =voltmeter(BATTERY)*amperemeter(BATTERY);															//	Определяем временную переменную для хранения мощьности на входе DC-DC преобразователя.
			float Pout=voltmeter(OUTPUT) *I_OUT_USER;																	//	Определяем временную переменную для хранения мощьности на выходе DC-DC преобразователя.
			if(Pin==0){return 0;}																						//	Если Pin равно 0, то возвращаем 0 и выходим из функции, так как в следующей строке Pin является делителем.
			if((Pout/Pin)>1.0){return 0;}																				//	Если абсолютное значение КПД > 1, то мы изобрели вечную батарейку, сохраним коммерческую тайну и вернём 0%.
			return (Pout/Pin)*100.0;																					//	КПД = (Pout/Pin) * 100%.
}																														//
																														//
//		Получение значения АЦП:																							//	Возвращаемое значение: АЦП (может быть отрицательным).
float	Battery_Shield::_ADC(uint8_t reg){																				//	Параметр: номер первого регистра.
			_noSleep();																									//	Запрещаем модулю отключаться при отсутствии нагрузки.
			if(	objI2C->readBytes(IP5108_ADDRESS, reg, valRegistor, 2) ){												//	Если удалось прочитать 2 байта начиная с регистра reg в массив valRegistor, то ...
			int16_t	i  = (valRegistor[1] & 0x3F) << 8;																	//	Сохраняем старший байт прочитанного значения сбрасывая два старших бита (7-6).
					i |=  valRegistor[0];																				//	Добавляем младший байт прочитанного значения.
					if(i & 0x2000L){ i |= 0xC000L; }																	//	Если 13 бит установлен в «1» значит текущее число отрицательное, преобразуем его из 14 битного отрицательного в 16 битное отрицательное (устанавливая биты 15 и 14 в «1»).
					return float(i);																					//	Возвращаем результат.
			}else{	return 0;}																							//	Иначе, если не удалось прочитать 2 байта начиная с регистра reg, то возвращаем 0.
}																														//
																														//
//		Запрет перехода в спящий режим при отсутствии нагрузки:															//	Возвращаемое значение: успех выполнения запрета true/false.
bool	Battery_Shield::_noSleep(void){																					//	Параметр: отсутствует.
//			Ждём ответа модуля:																							//
			if(objI2C->readBytes(IP5108_ADDRESS,IP5108_SYS_CTL1,valRegistor,1)){										//	Если удалось прочитать значение регистра IP5108_SYS_CTL1 в элемент массива valRegistor[0], то ...
			if(valRegistor[0] & bit(1)){																				//	Если 1 бит байта ответа модуля установлен в «1», то ...
				objI2C->writeByte(IP5108_ADDRESS, IP5108_SYS_CTL1, (valRegistor[0]&(~bit(1))) );						//	Сохраняем значение valRegistor[0] в регистр IP5108_SYS_CTL1, предварительно сбросив 1 бит.
			}		return true;																						//	Возвращаем true (запрет удалось отправить, или не требуется отправлять).
			}else{	return false;}																						//	Иначе, если не удалось прочитать значение регистра IP5108_SYS_CTL1, то возвращаем false.
}																														//
